{
  "name": "mers",
  "version": "0.13.1",
  "private": false,
  "author": {
    "name": "Justin Spears",
    "email": "speajus@gmail.com"
  },
  "dependencies": {
    "body-parser": "^1.10.2",
    "concat-stream": "~1.4.7",
    "errorhandler": "^1.3.0",
    "mongoose": "^4.0.0",
    "nojector": "^0.2.0",
    "underscore": "^1.7.0"
  },
  "devDependencies": {
    "mocha": "^2.1.0",
    "pow-mongoose-fixtures": "latest",
    "body-parser": "~1.10.0",
    "should": "^5.1.0",
    "express": "^4.10.7",
    "mongoose": "3.8.25",
    "supertest": "^0.15.0"
  },
  "peerDependencies": {
    "mongoose": "^3.8.21"
  },
  "scripts": {
    "test": "mocha test/*-mocha.js"
  },
  "keywords": [
    "framework",
    "json",
    "express",
    "mongoose",
    "rest",
    "restful"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:jspears/mers"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "#Mers\n *_Mongoose\n *_Express\n *_Rest\n *_Service\n \n    Mers is a plugin for express to expose mongoose finders as simple crud/rest operations.  The\n    basic idea being you should just define your model/finders and the rest should be be magic.\n\n![build status](https://travis-ci.org/jspears/mers.svg)\n\n## Usage\n\nInstall mers, mongoose, express and body-parser\n\n```sh\n  $ npm install express --save\n  $ npm install mongoose --save\n  $ npm install body-parser --save\n  $ npm install mers --save\n\n```\n\n```javascript\n    //You really need body parser for things to work correctly\n     var express = require('express'),\n        mongoose = require('mongoose'),\n        Schema = mongoose.Schema,\n        bodyParser = require('body-parser')\n\n    app.use(bodyParser.json())\n    app.use(bodyParser.urlencoded({ extended: true }));\n    var SampleSchema = new Schema({\n        name:String,\n        age:Number\n    });\n\n    mongoose.model('sample', SampleSchema);\n    var mers = require('mers');\n    app.use('/rest', mers({uri:'mongodb://localhost/your_db'}).rest());\n\n```\nConfiguration options include:\n* `uri:uri://mongoose`  (as shown above)\n* `mongoose:{mongoose}` (your mongoose instance)\n* `error:{function}` (your custom Error Handler)\n* `responseStream:{function}` (your custom respost stream. See: lib/streams.js)\n* `transformer:{function}` (your custom transformer factory)\n# `inject:{Nojector}` (custom nojector add resovlers, or whatever)\n\n###If you had a schema such as\n   ```javascript\nvar mongoose = require('mongoose'), Schema = mongoose.Schema,\n    ObjectId = mongoose.Schema.ObjectId;\n\nvar CommentSchema = new Schema({\n    title:String, body:String, date:Date\n});\n\n\nvar BlogPostSchema = new Schema({\n    author:ObjectId,\n    title:String,\n    body:String,\n    buf:Buffer,\n    date:Date,\n    comments:[CommentSchema],\n    meta:{\n        votes:Number, favs:Number\n    }\n});\n/**\n * Note this must return a query object.   If it doesn't well, I dunno what it'll do.\n * @param q\n * @param term\n */\nBlogPostSchema.statics.findTitleLike = function findTitleLike(q, term) {\n    return this.find({'title':new RegExp(q.title || term.shift() || '', 'i')});\n}\nvar Comment = module.exports.Comment = mongoose.model('Comment', CommentSchema);\nvar BlogPost = module.exports.BlogPost = mongoose.model('BlogPost', BlogPostSchema);\n```\n\nyou could then access it at\n    listing.\n    \n    http://localhost:3000/rest/blogpost/\n    http://localhost:3000/rest/blogpost/$id\n    http://localhost:3000/rest/blogpost/$id/comments\n    http://localhost:3000/rest/blogpost/$id/comments/$id\n    http://localhost:3000/rest/blogpost/$id/comments/0\n    http://localhost:3000/rest/blogpost/finder/findTitleLike/term\n    \n    \n###Pagination\nPagination is also supported via skip= and limit= query params.\n\n    http://localhost:3000/rest/blogpost/$id?skip=10&limit=10\n\n###Population\nMongoose populate is supported, but this will be changing shortly to allow for more\nfine grained controll over population.  Currently you can do\n\n    http://localhost:3000/rest/blogpost?populate=comments\n\nor to specify particular fields.\n\n    http://localhost:3000/rest/blogpost?skip=10&populate[comments]=title,date\n\n\n\n###Filter\nFiltering is available for strings. To find all the blog posts with C in the title.\n\n    http://localhost:3000/rest/blogpost?filter[title]=C\n\nAlso you can and or nor the filters by using + (and) - (nor)  or nothing or\n    http://localhost:3000/rest/blogpost?filter[-title]=C\n    http://localhost:3000/rest/blogpost?filter[+title]=C&filter[-body]=A\n\n\n\nTo filter all String fields that have a C in them\n\n    http://localhost:3000/rest/blogpost?filter=C\n\n\n###Sorting\nSorting is supported 1 ascending -1 ascending.\n\n  http://localhost:3000/rest/blogpost?sort=title:1,date:-1\n\n###Transformer\nTransformers can be registered on startup.  A simple TransformerFactory is\nincluded.  If the function returns a promise, it will resolve the transformer\nasynchronously.   The transformers follow the same injection rules.\n\nTo transform asynchronously just return a promise from your function.  You can\nchain transformers.  Transformers can also inject, but the first argument should\nbe the object you want to transform.\n\n\n```javascript\n\napp.use('/rest', require('mers').rest({\n    mongoose:mongoose,\n    transformers:{\n           renameid: function(obj){\n                obj.id = obj._id;\n                delete obj._id;\n                //don't forget to return the object.  Null will filter it from the results.\n                return obj;\n           },\n           /**\n            Injects the user into the function, and checks if the\n            owner is the same as the current user.  Works with passport.\n           */\n           checkUser:function(obj, session$user){\n              if (obj.owner_id !== session$user._id){\n                //returning null, short circuits the other transformers. And will\n                //not be included in the response.\n                return null;\n              }else{\n               return obj;\n              }\n\n           },\n           /**\n             Uses injection and async resolution.\n           */\n           async:function(obj, query$doIt){\n             if (query$doIt){\n                var p = promise();\n                setTimeout(function(){\n                    obj.doneIt =true;\n                    //Mpromise resolve.  Should work with other promises, or any object with a then function.\n                    p.resolve(null, obj);\n                },50);\n                return p;\n             }else{\n             return obj;\n             }\n\n           }\n      }\n    }));\n}\n```\n\n\n\nto get results transformered just add\n\n     http://localhost:3000/rest/blogpost?transform=renameid\n\n\n\nIt handles  get/put/post/delete I'll add some docs on that some day, but pretty much as you expect, or I expect anyways.\nsee tests/routes-mocha.js for examples.\n\n###Static Finders\nIt should also be able to be used with Class finders. Now handles class finders. Note: They must return  a query object.\nThey are passed the query object and the rest of the url. All of the populate's, filters, transforms should work.\n\n```javascript\n\n/**\n * Note this must return a query object.\n * @param q\n * @param term\n */\nBlogPostSchema.statics.findTitleLike = function findTitleLike(q, term) {\n    return this.find({'title':new RegExp(q.title || term.shift(), 'i')});\n}\n```\n\nSo you can get the url\n\n\n```\nhttp://localhost:3000/rest/blogpost/finder/findTitleLike?title=term\n```\n\nor\n\n```\nhttp://localhost:3000/rest/blogpost/finder/findTitleLike/term\n```\n\n#### Promises with finders\nOccassionally you may want to do something like a double query within a finder.   Mers has got your back.\n\n```javascript\n      BlogPostSchema.statics.findByCallback = function onFindByCallback(query$id) {\n          return this.find({_id: query$id}).exec();\n      }\n\n\n```\n\n\n### Error Handling ###\nTo create a custom error handler\n\n```javascript\n\n   app.use('/rest', rest({\n         error : function(err, req, res, next){\n               res.send({\n                   status:1,\n                   error:err && err.message\n               });\n           }).rest());\n\n```\n\n\n### Custom ResultStream\nYou can create your own result stream. It needs to subclass Stream and be writable.  This can allow\nfor other formats, and preventing the wrapping of data in the payload.\n\n\n##Method\nYou can invoke a method on a model.  This useful to expose more complicated things\nthat can't just be filtered.   Of course you can return nested nestings too...\n\n\n###Returning an Object\nThis one just returns an object, from /department/$id/hello/name\n\n```javascript\nDepartmentSchema.methods.hello = function DepartmentSchema$hello(){\n    return {name:'hello '+this.name};\n}\n```\n\n###Returning a Promise.\nThis is returns a promise from /department/$id/promises.  Really you just\nneed to return an object with an then function.  So any promise library should work.\n\n```javascript\nDepartmentSchema.methods.promises = function (data){\n    var p = promise();\n    setTimeout(p.resolve.bind(p, null, {name:'hello '+this.name}), 100);\n    return p;\n}\n```\n\n### Returning a Query object.\nThis is returns a query from /department/$id/superDo\n\n```javascript\nDepartmentSchema.methods.superDo = function DepartmentSchema$hello(data){\n   return Department.find({\n       _id:this._id\n   });\n}\n```\n\n##Examples.\nAn example of a customized rest service can be found at\n\n    https://github.com/jspears/backbone-directory\n\n\n##Parameter injection\nWhen invoking a method you often need data from the request to process.  To do this\nwe have an injection system.   You can inject a method on a model, or a transformer.\n\nIt resolves the prefix of the parameter name deliminated by $ to the scope.  See\n nojector for more information there. The built in resolvers are\nsession,\nparam,\nquery,\nbody,\nargs,\nrequire\n\n```\nurl: http://localhost/rest/department/finders/byName?name=Stuff\n```\n\n\n```javascript\nDepartmentSchema.static.byName = function DepartmentSchema$hello(query$name){\n   return Department.find({\n        name:query$name\n       });\n}\n```\n\nworks on instances to...\n\n```\nurl: http://localhost/rest/department/$id/hello/?name=STuff\n```\n\n\n```javascript\nDepartmentSchema.method.hello = function DepartmentSchema$hello(query$name, session$user){\n    //session.user === session$user\n   return Department.find({\n        name:query$name\n       });\n       \n}\n```\n\n\n### Delete\nDeleting is follows the rules of as a put, however, it has an option, of deleteRef, when you\nare deleteing a nested ref'd object and want to delete it from the refer'd collection. see\nroutes-user-mocha.js\n\n\n\n",
  "readmeFilename": "Readme.md",
  "description": "*_Mongoose  *_Express  *_Rest  *_Service",
  "bugs": {
    "url": "https://github.com/jspears/mers/issues"
  },
  "_id": "mers@0.13.1",
  "dist": {
    "shasum": "4893f31b1d81b1b62abfff78e99f422d115cb7f2"
  },
  "_from": "mers@latest",
  "_resolved": "https://registry.npmjs.org/mers/-/mers-0.13.1.tgz"
}
